# ---------- صف حلقه‌ای (Circular Queue) ----------
class CircularQueue:
    def init(self, size=10):
        # ایجاد صف حلقه‌ای با ظرفیت مشخص
        self.size = size
        self.queue = [None] * size
        self.front = -1
        self.rear = -1

    def is_empty(self):
        # بررسی خالی بودن صف
        return self.front == -1

    def is_full(self):
        # بررسی پر بودن صف به صورت حلقه‌ای
        return (self.rear + 1) % self.size == self.front

    def enqueue(self, x):
        # افزودن عنصر به صف در صورت وجود ظرفیت
        if self.is_full():
            return False
        if self.is_empty():
            self.front = self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = x
        return True

    def dequeue(self):
        # حذف و بازگرداندن عنصر ابتدای صف
        if self.is_empty():
            return None
        value = self.queue[self.front]
        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return value


# ---------- پشته (Stack) ----------
class Stack:
    def init(self):
        # ایجاد ساختار داخلی پشته
        self.stack = []

    def push(self, x):
        # افزودن عنصر به بالای پشته
        self.stack.append(x)

    def pop(self):
        # حذف و بازگرداندن عنصر بالای پشته
        if not self.stack:
            return None
        return self.stack.pop()

    def stack_empty(self):
        # بررسی خالی بودن پشته
        return len(self.stack) == 0


# ---------- صف حلقه‌ای با اولویت (Priority Circular Queue) ----------
class PriorityCircularQueue(CircularQueue, Stack):

    def init(self, size=10):
        CircularQueue.init(self, size)
        Stack.init(self)

    def enqueue_with_priority(self, x):
        """
        افزودن عنصر به صف و مرتب‌سازی کل عناصر
        به ترتیب نزولی (اولویت‌بندی)
        """
        if self.is_full():
            return False
        data = self.get_elements()
        data.append(x)
        data.sort(reverse=True)
        self.clear()
        for item in data:
            self.enqueue(item)
        return True

    def dequeue_priority(self):
        # حذف عنصر با اولویت (عنصر ابتدای صف)
        return self.dequeue()

    def peek(self):
        # مشاهده عنصر ابتدای صف بدون حذف
        if self.is_empty():
            return None
        return self.queue[self.front]

    def get_elements(self):
        """
        استخراج همه عناصر موجود در صف به صورت لیست
        با رعایت ترتیب از front تا rear
        """
        if self.is_empty():
            return []
        result = []
        i = self.front
        while True:
            result.append(self.queue[i])
            if i == self.rear:
                break
            i = (i + 1) % self.size
        return result

    def clear(self):
        # پاکسازی کل صف
        self.front = self.rear = -1
        self.queue = [None] * self.size

    def count(self):
        # شمارش تعداد عناصر موجود در صف
        return len(self.get_elements())

    def contains(self, x):
        # بررسی وجود عنصر مشخص در صف
        return x in self.get_elements()

    def reverse(self):
        """
        معکوس کردن ترتیب عناصر صف
        با استفاده از پشته
        """
        for x in self.get_elements():
            self.push(x)
        self.clear()
        while not self.stack_empty():
            self.enqueue(self.pop())

    def move_to_stack(self):
        # انتقال عناصر صف به پشته داخلی
        for x in self.get_elements():
            self.push(x)

    def display(self):
        # نمایش عناصر موجود در صف
        print(self.get_elements())
